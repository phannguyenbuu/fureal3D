/*
Auto-generated by: https://github.com/pmndrs/gltfjsx
Command: npx gltfjsx@6.5.3 Light_Third.glb 
*/

import React, {useEffect, useRef } from "react";
import { useGLTF } from "@react-three/drei";
import { convertMaterialsToBasic } from "../../utils/convertToBasic";
import * as THREE from 'three';
import { ContactShadows } from '@react-three/drei';




export const createMtl = (img) => {
  const textureLoader = new THREE.TextureLoader();
  const floorTexture = textureLoader.load(
    img,
    (tex) => {
      tex.encoding = THREE.sRGBEncoding; // để màu sắc chính xác
      // tex.anisotropy = Math.min(renderer.capabilities.getMaxAnisotropy(), 16); // tăng anisotropy cho texture sắc nét khi nghiêng
      tex.minFilter = THREE.LinearMipMapLinearFilter;
      tex.magFilter = THREE.LinearFilter;
      tex.wrapS = THREE.RepeatWrapping;
      tex.wrapT = THREE.RepeatWrapping;
    },
    undefined,
    (err) => {
      console.error('Texture loading error:', err);
    }
  );
  return new THREE.MeshStandardMaterial({ map: floorTexture });
};


export const glassMaterial = new THREE.MeshPhysicalMaterial({
  color: 0xffffff,
  metalness: 0,
  roughness: 0,
  transmission: 1,       // tạo hiệu ứng trong suốt như kính
  thickness: 0.5,         // độ dày của kính
  clearcoat: 1,
  clearcoatRoughness: 0,
  reflectivity: 0.2,
  transparent: true,
  opacity: 1,
  envMapIntensity: 1,     // độ mạnh phản xạ môi trường
});

const glossyAluminumMaterial = new THREE.MeshPhysicalMaterial({
  color: 0xaaaaaa,       // màu nhôm sáng xám
  metalness: 0.2,        // kim loại hoàn toàn
  roughness: 0.1,        // độ nhám thấp tạo bề mặt bóng cao
  clearcoat: 1.0,        // lớp phủ bóng cao
  clearcoatRoughness: 0, // lớp phủ cực bóng, không nhám
  reflectivity: 0.7,     // độ phản chiếu vật liệu
  envMapIntensity: 1.0,  // độ mạnh phản chiếu môi trường nếu có envMap
});

export const UVWPlaneXY = (node) => {
  if (!node.geometry.boundingBox) {
    node.geometry.computeBoundingBox();
  }
  const bbox = node.geometry.boundingBox;
  const min = bbox.min;
  const max = bbox.max;
  const uvAttribute = node.geometry.attributes.uv;
  const position = node.geometry.attributes.position;
  
  for (let i = 0; i < uvAttribute.count; i++) {
    const x = position.getX(i);
    const y = position.getY(i);

    const u = (x - min.x) / (max.x - min.x);
    const v = (y - min.y) / (max.y - min.y);
    uvAttribute.setXY(i, u, v);
  }
  uvAttribute.needsUpdate = true;
};


export const UVWPlaneXZ = (node) => {
  if (!node.geometry.boundingBox) {
    node.geometry.computeBoundingBox();
  }
  const bbox = node.geometry.boundingBox;
  const min = bbox.min;
  const max = bbox.max;
  const uvAttribute = node.geometry.attributes.uv;
  const position = node.geometry.attributes.position;

  for (let i = 0; i < uvAttribute.count; i++) {
    const x = position.getX(i);
    const z = position.getZ(i);

    const u = (x - min.x) / (max.x - min.x);
    const v = (z - min.z) / (max.z - min.z);
    uvAttribute.setXY(i, u, v);
  }
  uvAttribute.needsUpdate = true;
};


export const UVWPlaneYZ = (node) => {
  if (!node.geometry.boundingBox) {
    node.geometry.computeBoundingBox();
  }
  const bbox = node.geometry.boundingBox;
  const min = bbox.min;
  const max = bbox.max;
  const uvAttribute = node.geometry.attributes.uv;
  const position = node.geometry.attributes.position;
  
  for (let i = 0; i < uvAttribute.count; i++) {
    const y = position.getY(i);
    const z = position.getZ(i);

    const u = (y - min.y) / (max.y - min.y);
    const v = (z - min.z) / (max.z - min.z);
    uvAttribute.setXY(i, u, v);
  }
  uvAttribute.needsUpdate = true;
};


export default function Model(props) {
  const { nodes, materials } = useGLTF("/models/Light Room/boxroom.glb");
  const groupRef = useRef();

  const newMaterials = convertMaterialsToBasic(materials);
  const greyMaterial = new THREE.MeshStandardMaterial({ color: "grey" });
  
  const isNode = (node) => {
    return true;
  }

  useEffect(() => {
    // Object.values(nodes).forEach((node) => {
    //   console.log("Node", node.name);

    //   if (isNode(node)) {
    //     // Lấy bounding box của node
    //     const bbox = new THREE.Box3().setFromObject(node);
    //     console.log("Bounding Box Min:", bbox.min);
    //     console.log("Bounding Box Max:", bbox.max);

    //     if(node.name === "SampleRoom_Room_1")
    //       UVWPlaneXZ(node);
    //     else if(node.name === "SampleRoom_Room_4")
    //       UVWPlaneXZ(node);
    //     else if(node.name === "SampleRoom_Room_5") //Door
    //       UVWPlaneYZ(node);
    //     else if(node.name === "SampleRoom_Room_6")
    //       UVWPlaneXZ(node);
    //   }
    // });

    // Object.values(materials).forEach(mtl => {
    //   console.log('mtl',mtl);
    // });
  }, [nodes]);

  return (
    <group {...props} dispose={null} ref={groupRef} 
      scale={[1,1,1]} position={[2,0,-2.5]} castShadow receiveShadow>
        
        
      {/* <mesh
          geometry={nodes.SampleRoom_Room_4.geometry}
          
          material={createMtl('/models/Light Room/floor.jpg')}
        />
      <mesh name="Glass"
          geometry={nodes.SampleRoom_Room_2.geometry}
          
          material={glassMaterial}
        />
      <mesh name="Wall"
          geometry={nodes.SampleRoom_Room_1.geometry}
          material={createMtl('/models/Light Room/wall_shadow.jpg')}
        />
      <mesh name="Alumium"
        geometry={nodes.SampleRoom_Room_3.geometry}
          
          material={glossyAluminumMaterial}
        />

      <mesh name="Door"
        geometry={nodes.SampleRoom_Room_5.geometry}
          material={createMtl('/models/Light Room/AI19_004_bump_wood.jpg')}
        />
        
      <mesh name="Wall_Door"
        geometry={nodes.SampleRoom_Room_6.geometry}
          material={createMtl('/models/Light Room/wall.jpg')}
        /> */}


      {Object.values(nodes).map(
          (node, index) =>
            node.geometry && (
              <mesh
                key={index}
                geometry={node.geometry}
                material={materials[node.material?.name] || materials.default}
                position={node.position}
                rotation={node.rotation}
                scale={node.scale}
              />
            )
        )}
    
      
    </group>
  );
}

useGLTF.preload("/models/Light Room/Light_Third.glb");
useGLTF.preload("/models/Light Room/obj/Bed.glb");
useGLTF.preload("/models/Light Room/obj/Bedtab.glb");
useGLTF.preload("/models/Light Room/obj/Bench.glb");
useGLTF.preload("/models/Light Room/obj/direction.glb");
useGLTF.preload("/models/Light Room/obj/WorkTable.glb");
useGLTF.preload("/models/Light Room/obj/Readchair.glb");
useGLTF.preload("/models/Light Room/obj/Wardrobe1m2.glb");
useGLTF.preload("/models/Light Room/obj/Wardrobe2m4.glb");
useGLTF.preload("/models/Light Room/obj/Wardrobe3m6.glb");